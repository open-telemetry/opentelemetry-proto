// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/open-telemetry/opentelemetry-proto/gen/go/metrics/v1";

message ResourceMetrics {
  opentelemetry.proto.resource.v1.Resource resource = 1;

  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

message InstrumentationLibraryMetrics {
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  repeated Metric metrics = 2;
}

message Metric {
  MetricDescriptor metric_descriptor = 1;

  repeated DataPoint points = 2;
}

message MetricDescriptor {
  string name = 1;
  string description = 2;
  string unit = 3;

  enum ValueType {
    INVALID_VALUE_TYPE = 0;

    SCALAR_INT64     = 2;
    SCALAR_DOUBLE    = 3;

    HISTOGRAM_INT64  = 4;
    HISTOGRAM_DOUBLE = 5;

    SUMMARY_INT64    = 6;
    SUMMARY_DOUBLE   = 7;

    RAW_INT64        = 8;
    RAW_DOUBLE       = 9;

    // TODO: Sketches can be represented in various ways, depending on
    // the technique.  One viable representation simply uses weighted
    // RAW_* value types (e.g., a T-digest can be encoded this way).
  }

  ValueType value_type = 4;

  enum KindMask {
    INVALID_KIND_MASK = 0;

    // One of the following three MUST be set. There are 3 exclusive Temporality kinds.
    INSTANTANEOUS = 0x1;
    CUMULATIVE    = 0x2;
    DELTA         = 0x4;

    // One of the following two MUST be set. There are 2 exclusive Structure kinds.
    GROUPING      = 0x8;
    ADDING        = 0x10;

    // May be set with ADDING.
    MONOTONIC     = 0x20;

    // May be set for any instrument.
    SYNCHRONOUS   = 0x40;
  }

  enum Kind {
    INVALID_KIND = 0;

    // The following codes are generated from the valid combinations of the mask bits above.
    
    ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS  = 0x71;
    ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS = 0x31;
    ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS     = 0x72;
    ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS    = 0x32;
    ADDING_MONOTONIC_DELTA_SYNCHRONOUS          = 0x74;
    ADDING_MONOTONIC_DELTA_ASYNCHRONOUS         = 0x34;

    ADDING_INSTANTANEOUS_SYNCHRONOUS            = 0x51;
    ADDING_INSTANTANEOUS_ASYNCHRONOUS           = 0x11;
    ADDING_CUMULATIVE_SYNCHRONOUS               = 0x52;
    ADDING_CUMULATIVE_ASYNCHRONOUS              = 0x12;
    ADDING_DELTA_SYNCHRONOUS                    = 0x54;
    ADDING_DELTA_ASYNCHRONOUS                   = 0x14;

    GROUPING_INSTANTANEOUS_SYNCHRONOUS          = 0x49;
    GROUPING_INSTANTANEOUS_ASYNCHRONOUS         = 0x9; 
    GROUPING_CUMULATIVE_SYNCHRONOUS             = 0x4a;
    GROUPING_CUMULATIVE_ASYNCHRONOUS            = 0xa; 
    GROUPING_DELTA_SYNCHRONOUS                  = 0x4c;
    GROUPING_DELTA_ASYNCHRONOUS                 = 0xc; 
  }

  Kind kind = 5;
}

message DataPoint {
  // (Same comment)
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

  // (Same comment)
  // If omitted and not instantaneous, this is taken as the default _REPORT_TIMESTAMP_.
  fixed64 start_time_unix_nano = 2;

  // (Same comment)
  // Use this in conjunction with `value_int64` and `value_double`, or `summary`.
  // When the kind is instantaneous, this field applies to *this point*.  
  fixed64 time_unix_nano = 3;

  // A logical oneof among the following fields, as prescribed by ValueType:

  // INT64/FLOAT ADDING -> Sum (Counter), Grouping -> RAW (Gauge); This
  // could be "last value" or it could be a random value (or other
  // selection approach)
  int64 value_int64 = 4;
  double value_double = 5;

  // HISTOGRAM
  // (Similar comments)
  // Note this is an exact representation for Adding instruments.
  Histogram histogram = 6;

  // SUMMARY
  // (see changes below)
  Summary summary = 7;

  // Optional exemplars
  repeated RawValue exemplars = 8;
}

// Summary is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
message Summary {
  // Remove the labels, start_time, and time TODO.
  //
  // fields: Add min, max, last fields
  // as described in https://github.com/open-telemetry/oteps/pull/117
  //
  // (Same comment)
  uint64 count = 1;

  // (Same comment)
  int64  sum_int64 = 2;
  double sum_double = 3;

  // MIN, MAX, LAST value
  int64  min_int64 = 4;
  double min_double = 5;

  int64  max_int64 = 6;
  double max_double = 7;

  int64  last_int64 = 8;
  double last_double = 9;
  
  // (Similar comments)
  message ValueAtQuantile {
    double quantile = 1;  // [0,1], if 0 prefer MIN, if 1 prefer MAX.
    int64  value_int64 = 2;
    double value_double = 3;
  }

  // (Same comment)
  repeated ValueAtQuantile quantile_values = 10;
}

message RawValue {
  // Numerical value of the measurement that was recorded. Only one of these 
  // two fields is used for the data, based on MetricDescriptor.measurement_type
  double value_double = 1;
  int64 value_int64 = 2;

  // Exact time that the measurement was recorded
  fixed64 time_unix_nano = 3;

  // Labels that were passed with the measurement, but not included in the DataPoint's labels
  repeated opentelemetry.proto.common.v1.StringKeyValue additional_labels = 4;

  // (Optional) Span ID of the current trace
  bytes span_id = 5;

  // (Optional) Trace ID of the current trace
  bytes trace_id = 6;

  // (Optional) When sample_count is non-zero, this exemplar has been chosen in a statistically
  // unbiased way such that the exemplar is representative of `sample_count` individual events
  double sample_count = 7;
}

message Histogram {
  // count is the number of values in the population. Must be non-negative. This value
  // must be equal to the sum of the "count" fields in buckets if a histogram is provided.
  uint64 count = 1;

  // sum of the values in the population. If count is zero then this field
  // must be zero. This value must be equal to the sum of the "sum" fields in buckets if
  // a histogram is provided.
  int64 sum_int64 = 2;
  double sum_double = 3;

  // Bucket contains values for a bucket.
  message Bucket {
    // The number of values in each bucket of the histogram, as described by
    // bucket_options.
    uint64 count = 1;
  }

  // buckets is an optional field contains the values of histogram for each bucket.
  //
  // The sum of the values in the buckets "count" field must equal the value in the count field.
  //
  // The number of elements in buckets array must be by one greater than the
  // number of elements in bucket_bounds array.
  //
  // Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  // must also be present and number of elements in this field must be equal to the
  // number of buckets defined by bucket_options.
  repeated Bucket buckets = 6;

  // A histogram may optionally contain the distribution of the values in the population.
  // In that case one of the option fields below and "buckets" field both must be defined.
  // Otherwise all option fields and "buckets" field must be omitted in which case the
  // distribution of values in the histogram is unknown and only the total count and sum are known.

  // explicit_bounds is the only supported bucket option currently.
  // TODO: Add more bucket options.

  // explicit_bounds specifies buckets with explicitly defined bounds for values.
  // The bucket boundaries are described by "bounds" field.
  //
  // This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  // at index i are:
  //
  // [0, bounds[i]) for i == 0
  // [bounds[i-1], bounds[i]) for 0 < i < N-1
  // [bounds[i], +infinity) for i == N-1
  // The values in bounds array must be strictly increasing and > 0.
  //
  // Note: only [a, b) intervals are currently supported for each bucket. If we decides
  // to also support (a, b] intervals we should add support for these by defining a boolean
  // value which decides what type of intervals to use.
  repeated int64 explicit_bounds_int64 = 7;
  repeated double explicit_bounds_double = 8;
}
